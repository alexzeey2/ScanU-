<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Balance Scanner - AI Account Balance Detector</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="AI-Powered Bank Account Balance Detection System. Point your camera at people to detect their estimated account balance in real-time!">
    <meta name="theme-color" content="#1e3a8a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Balance Scanner">
    <link rel="manifest" href="/manifest.json">
    
    <!-- Favicons -->
    <link rel="icon" type="image/webp" href="/logo.webp">
    <link rel="icon" type="image/png" sizes="192x192" href="/logo-192.png">
    <link rel="apple-touch-icon" href="/logo-192.png">
    <link rel="shortcut icon" href="/logo.webp">
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7"></script>
    <script>
        // Polyfill for roundRect (not supported in all browsers)
        if (typeof CanvasRenderingContext2D !== 'undefined' && !CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radii) {
                const radius = typeof radii === 'number' ? radii : radii[0] || 0;
                this.beginPath();
                this.moveTo(x + radius, y);
                this.lineTo(x + width - radius, y);
                this.quadraticCurveTo(x + width, y, x + width, y + radius);
                this.lineTo(x + width, y + height - radius);
                this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                this.lineTo(x + radius, y + height);
                this.quadraticCurveTo(x, y + height, x, y + height - radius);
                this.lineTo(x, y + radius);
                this.quadraticCurveTo(x, y, x + radius, y);
                this.closePath();
                return this;
            };
        }

        // Check if browser supports required features
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            console.warn('Camera API not supported in this browser');
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
            min-height: 100vh;
            color: #1a202c;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            padding: 30px 20px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
            letter-spacing: -1px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.95;
            font-weight: 300;
        }

        .main-card {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            margin-bottom: 30px;
        }

        .upload-section {
            text-align: center;
            padding: 40px;
            border: 3px dashed #cbd5e0;
            border-radius: 15px;
            background: #f7fafc;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 20px;
        }

        .upload-section:hover {
            border-color: #1e3a8a;
            background: #edf2f7;
        }

        .upload-section.dragover {
            border-color: #1e3a8a;
            background: #e6fffa;
        }

        .upload-icon {
            font-size: 3em;
            margin-bottom: 15px;
            color: #1e3a8a;
        }

        .upload-section h3 {
            font-size: 1.3em;
            margin-bottom: 10px;
            color: #2d3748;
        }

        .upload-section p {
            color: #718096;
            font-size: 0.95em;
        }

        .btn {
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
            color: white;
            border: none;
            padding: 15px 35px;
            font-size: 1.1em;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(30, 58, 138, 0.4);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(30, 58, 138, 0.6);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: white;
            color: #1e3a8a;
            border: 2px solid #1e3a8a;
            margin-left: 10px;
        }

        .btn-secondary:hover {
            background: #1e3a8a;
            color: white;
        }

        .video-container {
            display: none;
            position: relative;
            margin-top: 30px;
        }

        .video-container.active {
            display: block;
        }

        #videoCanvas {
            width: 100%;
            height: auto;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        #cameraCanvas {
            width: 100%;
            height: auto;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        #cameraPreview {
            display: none;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 25px;
            flex-wrap: wrap;
        }

        .status {
            text-align: center;
            padding: 20px;
            margin-top: 20px;
            border-radius: 10px;
            font-weight: 500;
        }

        .status.processing {
            background: #fef5e7;
            color: #f39c12;
        }

        .status.ready {
            background: #e8f8f5;
            color: #16a085;
        }

        .status.error {
            background: #fadbd8;
            color: #c0392b;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e2e8f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
            display: none;
        }

        .progress-bar.active {
            display: block;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #1e3a8a, #3b82f6);
            width: 0%;
            transition: width 0.3s;
        }

        .wealth-overlay {
            position: absolute;
            background: rgba(26, 32, 44, 0.95);
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            font-weight: 700;
            font-size: 1.1em;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            pointer-events: none;
            border: 2px solid #48bb78;
            white-space: nowrap;
        }

        .history-section {
            margin-top: 40px;
        }

        .history-section h2 {
            margin-bottom: 20px;
            color: #2d3748;
            font-size: 1.8em;
        }

        .history-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .history-item {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.3s;
        }

        .history-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .history-thumbnail {
            width: 100%;
            height: 180px;
            object-fit: cover;
            background: #e2e8f0;
        }

        .history-info {
            padding: 15px;
        }

        .history-info h4 {
            margin-bottom: 8px;
            color: #2d3748;
            font-size: 1em;
        }

        .history-info p {
            color: #718096;
            font-size: 0.9em;
        }

        .info-badge {
            display: inline-block;
            background: #e6fffa;
            color: #234e52;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 600;
            margin-top: 8px;
        }

        input[type="file"] {
            display: none;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-left: 10px;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }
            
            .main-card {
                padding: 25px;
            }

            .controls {
                flex-direction: column;
            }

            .btn {
                width: 100%;
                margin-left: 0 !important;
                margin-top: 10px;
            }
        }

        /* Permission Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            animation: fadeIn 0.3s;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            max-width: 500px;
            margin: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            animation: slideUp 0.3s;
        }

        .modal-icon {
            font-size: 4em;
            margin-bottom: 20px;
        }

        .modal-content h2 {
            margin-bottom: 15px;
            color: #2d3748;
        }

        .modal-content p {
            color: #718096;
            margin-bottom: 25px;
            line-height: 1.6;
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        /* Install Button */
        .install-banner {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 15px 25px;
            border-radius: 50px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.3);
            display: none;
            align-items: center;
            gap: 15px;
            z-index: 999;
            animation: slideUp 0.3s;
        }

        .install-banner.active {
            display: flex;
        }

        .install-banner button {
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
            color: white;
            border: none;
            padding: 10px 25px;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.95em;
        }

        .install-banner .close-install {
            background: transparent;
            color: #718096;
            padding: 5px 10px;
            font-size: 1.2em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üí≥ Balance Scanner</h1>
            <p>AI-Powered Bank Account Balance Detection System</p>
        </div>

        <div class="main-card">
            <div class="upload-section" id="uploadSection">
                <div class="upload-icon">üìπ</div>
                <h3>Upload or Record Video</h3>
                <p>AI analyzes appearance and behavior to detect current account balance</p>
                <input type="file" id="fileInput" accept="video/*">
            </div>

            <div class="controls" style="justify-content: center;">
                <button class="btn" onclick="document.getElementById('fileInput').click()">
                    üìÅ Choose Video
                </button>
                <button class="btn btn-secondary" onclick="startCamera()">
                    üì∑ Live Camera
                </button>
                <button class="btn btn-secondary" onclick="startRecording()">
                    üé• Record Video
                </button>
            </div>

            <div class="progress-bar" id="progressBar">
                <div class="progress-fill" id="progressFill"></div>
            </div>

            <div class="status" id="status" style="display: none;"></div>

            <div class="video-container" id="cameraContainer" style="display: none;">
                <canvas id="cameraCanvas"></canvas>
                <video id="cameraPreview" autoplay playsinline style="display: none;"></video>
                <div class="controls">
                    <button class="btn" id="switchCameraBtn" onclick="switchCamera()">üîÑ Switch Camera</button>
                    <button class="btn btn-secondary" onclick="capturePhoto()">üì∏ Capture</button>
                    <button class="btn btn-secondary" onclick="stopCamera()">‚ùå Stop Camera</button>
                </div>
            </div>

            <div class="video-container" id="videoContainer">
                <canvas id="videoCanvas"></canvas>
                <div class="controls">
                    <button class="btn" id="playBtn" onclick="togglePlayPause()">‚ñ∂Ô∏è Play</button>
                    <button class="btn btn-secondary" onclick="resetVideo()">üîÑ New Video</button>
                    <button class="btn btn-secondary" onclick="saveAnalysis()">üíæ Save Analysis</button>
                </div>
            </div>
        </div>

        <div class="main-card history-section" id="historySection" style="display: none;">
            <h2>üìä Scan History</h2>
            <div class="history-grid" id="historyGrid"></div>
        </div>
    </div>

    <!-- Permission Modal -->
    <div class="modal" id="permissionModal">
        <div class="modal-content">
            <div class="modal-icon">üì∑</div>
            <h2>Camera Access Required</h2>
            <p>Balance Scanner needs access to your camera to detect and analyze people in real-time. Your privacy is protected - nothing is uploaded to any server.</p>
            <div class="modal-buttons">
                <button class="btn" onclick="requestCameraPermission()">Allow Camera</button>
                <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Install Banner -->
    <div class="install-banner" id="installBanner">
        <span>üì± Install Balance Scanner as an app!</span>
        <button onclick="installApp()">Install</button>
        <button class="close-install" onclick="closeInstallBanner()">‚úï</button>
    </div>

    <script>
        // PWA Installation
        let deferredPrompt;

        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            document.getElementById('installBanner').classList.add('active');
        });

        async function installApp() {
            if (!deferredPrompt) return;
            
            deferredPrompt.prompt();
            const { outcome } = await deferredPrompt.userChoice;
            
            if (outcome === 'accepted') {
                console.log('PWA installed');
            }
            
            deferredPrompt = null;
            document.getElementById('installBanner').classList.remove('active');
        }

        function closeInstallBanner() {
            document.getElementById('installBanner').classList.remove('active');
        }

        // Register Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('ServiceWorker registered:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('ServiceWorker registration failed:', error);
                    });
            });
        }
    </script>

    <script>
        let model;
        let currentVideo;
        let canvas, ctx;
        let cameraCanvas, cameraCtx;
        let videoFile;
        let isPlaying = false;
        let detections = [];
        let mediaRecorder;
        let recordedChunks = [];
        let cameraStream = null;
        let currentFacingMode = 'user'; // 'user' for front, 'environment' for back
        let isDetecting = false;

        // Initialize
        async function init() {
            canvas = document.getElementById('videoCanvas');
            ctx = canvas.getContext('2d');
            
            cameraCanvas = document.getElementById('cameraCanvas');
            cameraCtx = cameraCanvas.getContext('2d');
            
            // Check browser compatibility
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showStatus('‚ö†Ô∏è Your browser does not support camera access. Please use Chrome, Edge, or Safari.', 'error');
                return;
            }

            // Check for required APIs
            if (typeof Promise === 'undefined' || typeof fetch === 'undefined') {
                showStatus('‚ö†Ô∏è Your browser is too old. Please update to the latest version.', 'error');
                return;
            }
            
            showStatus('Loading AI Model...', 'processing');
            try {
                // Load BlazeFace model with timeout
                const loadPromise = blazeface.load();
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Model load timeout')), 15000)
                );
                
                model = await Promise.race([loadPromise, timeoutPromise]);
                showStatus('AI Model Ready ‚úì', 'ready');
                setTimeout(() => hideStatus(), 2000);
            } catch (error) {
                console.error('Model loading error:', error);
                showStatus('AI model loading failed. App will work with basic detection.', 'error');
                setTimeout(() => hideStatus(), 3000);
                model = null; // Continue without model
            }

            loadHistory();
        }

        // File upload
        document.getElementById('fileInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                videoFile = file;
                await processVideo(file);
            }
        });

        // Drag and drop
        const uploadSection = document.getElementById('uploadSection');
        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });

        uploadSection.addEventListener('dragleave', () => {
            uploadSection.classList.remove('dragover');
        });

        uploadSection.addEventListener('drop', async (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('video/')) {
                videoFile = file;
                await processVideo(file);
            }
        });

        // Process video
        async function processVideo(file) {
            showStatus('Processing Video...', 'processing');
            showProgress(true);

            const video = document.createElement('video');
            video.src = URL.createObjectURL(file);
            video.muted = true;
            
            await new Promise(resolve => {
                video.onloadedmetadata = resolve;
            });

            currentVideo = video;
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            // Analyze frames
            await analyzeVideo(video);

            document.getElementById('videoContainer').classList.add('active');
            showStatus('Analysis Complete! Click Play to view results', 'ready');
            showProgress(false);
        }

        // Analyze video
        async function analyzeVideo(video) {
            detections = [];
            const duration = video.duration;
            const frameInterval = 1; // Analyze every second
            const totalFrames = Math.floor(duration / frameInterval);

            for (let i = 0; i < totalFrames; i++) {
                const time = i * frameInterval;
                video.currentTime = time;
                
                await new Promise(resolve => {
                    video.onseeked = resolve;
                });

                updateProgress((i / totalFrames) * 100);

                // Draw frame
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                // Detect faces
                let faces = [];
                if (model) {
                    try {
                        faces = await model.estimateFaces(canvas, false);
                    } catch (e) {
                        console.error('Face detection error:', e);
                    }
                }

                // Generate wealth estimates for each face
                for (const face of faces) {
                    const wealth = estimateWealth(face, ctx, canvas);
                    detections.push({
                        time: time,
                        position: face.topLeft,
                        size: face.bottomRight,
                        wealth: wealth
                    });
                }

                // If no faces, create random detections for entertainment
                if (faces.length === 0 && i % 3 === 0) {
                    const randomWealth = generateRandomWealth();
                    detections.push({
                        time: time,
                        position: [canvas.width * 0.5, canvas.height * 0.3],
                        size: [canvas.width * 0.6, canvas.height * 0.5],
                        wealth: randomWealth
                    });
                }
            }

            video.currentTime = 0;
        }

        // Estimate wealth based on visual analysis
        function estimateWealth(face, ctx, canvas) {
            // Analyze region around face
            const x = Math.max(0, face.topLeft[0] - 50);
            const y = Math.max(0, face.topLeft[1] - 50);
            const width = Math.min(canvas.width - x, face.bottomRight[0] - face.topLeft[0] + 100);
            const height = Math.min(canvas.height - y, face.bottomRight[1] - face.topLeft[1] + 100);

            const imageData = ctx.getImageData(x, y, width, height);
            const data = imageData.data;

            let totalBrightness = 0;
            let colorVariance = 0;
            let saturatedPixels = 0;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                const brightness = (r + g + b) / 3;
                totalBrightness += brightness;

                const variance = Math.abs(r - g) + Math.abs(g - b) + Math.abs(b - r);
                colorVariance += variance;

                if (r > 200 || g > 200 || b > 200) {
                    saturatedPixels++;
                }
            }

            const avgBrightness = totalBrightness / (data.length / 4);
            const avgColorVariance = colorVariance / (data.length / 4);

            // Generate account balance based on heuristics
            let baseBalance = 25000; // 25k base

            // Brightness factor (well-lit = higher balance assumption)
            baseBalance += (avgBrightness - 128) * 200;

            // Color variance (varied colors = potentially better dressed/higher balance)
            baseBalance += avgColorVariance * 100;

            // Position factor (centered faces)
            const centerX = canvas.width / 2;
            const faceX = (face.topLeft[0] + face.bottomRight[0]) / 2;
            const proximity = 1 - Math.abs(faceX - centerX) / centerX;
            baseBalance += proximity * 50000;

            // Add randomness for variety
            const randomFactor = 0.3 + Math.random() * 1.5;
            baseBalance *= randomFactor;

            // Round to realistic bank balance values
            if (baseBalance < 5000) {
                return Math.round(baseBalance / 100) * 100; // Round to nearest ‚Ç¶100
            } else if (baseBalance < 100000) {
                return Math.round(baseBalance / 1000) * 1000; // Round to nearest ‚Ç¶1,000
            } else {
                return Math.round(baseBalance / 10000) * 10000; // Round to nearest ‚Ç¶10,000
            }
        }

        // Generate random account balance for entertainment
        function generateRandomWealth() {
            const ranges = [
                [500, 15000],      // Broke/struggling
                [15000, 100000],   // Average
                [100000, 500000],  // Comfortable
                [500000, 2000000], // Well-off
                [2000000, 10000000] // Rich (rare)
            ];
            
            // Weight towards lower balances (more realistic)
            const weights = [0.35, 0.35, 0.2, 0.08, 0.02];
            const random = Math.random();
            let cumulative = 0;
            let selectedRange = ranges[0];
            
            for (let i = 0; i < weights.length; i++) {
                cumulative += weights[i];
                if (random <= cumulative) {
                    selectedRange = ranges[i];
                    break;
                }
            }
            
            const balance = selectedRange[0] + Math.random() * (selectedRange[1] - selectedRange[0]);
            
            // Round appropriately
            if (balance < 5000) {
                return Math.round(balance / 100) * 100;
            } else if (balance < 100000) {
                return Math.round(balance / 1000) * 1000;
            } else {
                return Math.round(balance / 10000) * 10000;
            }
        }

        // Play video with overlays
        function togglePlayPause() {
            if (!currentVideo) return;

            if (isPlaying) {
                currentVideo.pause();
                document.getElementById('playBtn').innerHTML = '‚ñ∂Ô∏è Play';
                isPlaying = false;
            } else {
                currentVideo.play();
                document.getElementById('playBtn').innerHTML = '‚è∏Ô∏è Pause';
                isPlaying = true;
                renderFrame();
            }
        }

        // Render frame with overlays
        function renderFrame() {
            if (!isPlaying) return;

            ctx.drawImage(currentVideo, 0, 0, canvas.width, canvas.height);

            // Find detections for current time
            const currentTime = currentVideo.currentTime;
            const currentDetections = detections.filter(d => 
                Math.abs(d.time - currentTime) < 0.5
            );

            // Draw balance overlays
            for (const detection of currentDetections) {
                const x = detection.position[0];
                const y = detection.position[1] - 30;

                // Format balance with "Balance:" prefix
                const balanceText = 'Balance: ' + formatWealth(detection.wealth);

                // Draw background
                ctx.save();
                ctx.fillStyle = 'rgba(26, 32, 44, 0.95)';
                ctx.strokeStyle = '#48bb78';
                ctx.lineWidth = 2;
                
                ctx.font = 'bold 18px -apple-system, BlinkMacSystemFont, sans-serif';
                const textWidth = ctx.measureText(balanceText).width;
                const padding = 20;
                const boxWidth = textWidth + padding * 2;
                const boxHeight = 40;
                
                // Try roundRect, fallback to regular rect
                try {
                    ctx.beginPath();
                    if (typeof ctx.roundRect === 'function') {
                        ctx.roundRect(x - boxWidth/2, y - boxHeight/2, boxWidth, boxHeight, 20);
                    } else {
                        // Manual rounded corners
                        const radius = 20;
                        const rectX = x - boxWidth/2;
                        const rectY = y - boxHeight/2;
                        
                        ctx.moveTo(rectX + radius, rectY);
                        ctx.lineTo(rectX + boxWidth - radius, rectY);
                        ctx.quadraticCurveTo(rectX + boxWidth, rectY, rectX + boxWidth, rectY + radius);
                        ctx.lineTo(rectX + boxWidth, rectY + boxHeight - radius);
                        ctx.quadraticCurveTo(rectX + boxWidth, rectY + boxHeight, rectX + boxWidth - radius, rectY + boxHeight);
                        ctx.lineTo(rectX + radius, rectY + boxHeight);
                        ctx.quadraticCurveTo(rectX, rectY + boxHeight, rectX, rectY + boxHeight - radius);
                        ctx.lineTo(rectX, rectY + radius);
                        ctx.quadraticCurveTo(rectX, rectY, rectX + radius, rectY);
                        ctx.closePath();
                    }
                    ctx.fill();
                    ctx.stroke();
                } catch (error) {
                    // Fallback to simple rectangle
                    ctx.fillRect(x - boxWidth/2, y - boxHeight/2, boxWidth, boxHeight);
                    ctx.strokeRect(x - boxWidth/2, y - boxHeight/2, boxWidth, boxHeight);
                }

                // Draw text
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(balanceText, x, y);
                
                ctx.restore();
            }

            if (!currentVideo.paused) {
                requestAnimationFrame(renderFrame);
            }
        }

        // Format balance display
        function formatWealth(amount) {
            if (amount >= 1000000) {
                return '‚Ç¶' + (amount / 1000000).toFixed(1) + 'M';
            } else if (amount >= 1000) {
                return '‚Ç¶' + (amount / 1000).toFixed(0) + 'K';
            }
            return '‚Ç¶' + amount.toLocaleString();
        }

        // Reset
        function resetVideo() {
            // Stop camera if active
            if (cameraStream) {
                stopCamera();
            }

            if (currentVideo) {
                currentVideo.pause();
                currentVideo.currentTime = 0;
            }
            isPlaying = false;
            document.getElementById('playBtn').innerHTML = '‚ñ∂Ô∏è Play';
            document.getElementById('videoContainer').classList.remove('active');
            hideStatus();
        }

        // Save analysis
        function saveAnalysis() {
            if (!currentVideo || detections.length === 0) return;

            const analysis = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                detections: detections.length,
                avgBalance: Math.round(detections.reduce((sum, d) => sum + d.wealth, 0) / detections.length),
                maxBalance: Math.max(...detections.map(d => d.wealth)),
                duration: currentVideo.duration,
                thumbnail: canvas.toDataURL('image/jpeg', 0.5)
            };

            const history = JSON.parse(localStorage.getItem('balanceAnalysis') || '[]');
            history.unshift(analysis);
            
            // Keep only last 20
            if (history.length > 20) {
                history.pop();
            }

            localStorage.setItem('balanceAnalysis', JSON.stringify(history));
            
            showStatus('Analysis Saved Successfully!', 'ready');
            setTimeout(() => hideStatus(), 2000);
            
            loadHistory();
        }

        // Load history
        function loadHistory() {
            const history = JSON.parse(localStorage.getItem('balanceAnalysis') || '[]');
            
            if (history.length === 0) {
                document.getElementById('historySection').style.display = 'none';
                return;
            }

            document.getElementById('historySection').style.display = 'block';
            const grid = document.getElementById('historyGrid');
            grid.innerHTML = '';

            for (const item of history) {
                const card = document.createElement('div');
                card.className = 'history-item';
                
                const date = new Date(item.timestamp);
                const dateStr = date.toLocaleDateString('en-NG', { 
                    month: 'short', 
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });

                card.innerHTML = `
                    <img src="${item.thumbnail}" alt="Analysis" class="history-thumbnail">
                    <div class="history-info">
                        <h4>Balance Scan</h4>
                        <p>${dateStr}</p>
                        <p>${item.detections} people detected</p>
                        <div class="info-badge">Avg: ${formatWealth(item.avgBalance)}</div>
                    </div>
                `;

                grid.appendChild(card);
            }
        }

        // Live Camera Mode
        async function startCamera() {
            // Check if camera permission is already granted
            try {
                // Try to query permissions (not supported in all browsers)
                if (navigator.permissions && navigator.permissions.query) {
                    try {
                        const permissions = await navigator.permissions.query({ name: 'camera' });
                        
                        if (permissions.state === 'prompt') {
                            // Show modal to explain why we need permission
                            document.getElementById('permissionModal').classList.add('active');
                            return;
                        } else if (permissions.state === 'denied') {
                            showStatus('Camera access denied. Please enable camera in your browser settings.', 'error');
                            return;
                        }
                    } catch (permError) {
                        // Permissions API query failed, continue anyway
                        console.log('Permissions API not available, continuing...');
                    }
                }
                
                // Permission already granted or can't check, start camera
                await initializeCamera();
                
            } catch (error) {
                console.error('Permission check error:', error);
                // Fallback: try to initialize camera anyway
                await initializeCamera();
            }
        }

        // Request camera permission
        async function requestCameraPermission() {
            closeModal();
            await initializeCamera();
        }

        // Initialize camera
        async function initializeCamera() {
            try {
                // Stop any existing camera stream
                if (cameraStream) {
                    stopCamera();
                }

                showStatus('Starting Camera...', 'processing');

                const constraints = {
                    video: { 
                        facingMode: currentFacingMode,
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: false
                };

                cameraStream = await navigator.mediaDevices.getUserMedia(constraints);

                const video = document.getElementById('cameraPreview');
                video.srcObject = cameraStream;
                
                await new Promise((resolve, reject) => {
                    video.onloadedmetadata = resolve;
                    video.onerror = reject;
                    setTimeout(() => reject(new Error('Timeout')), 5000);
                });

                // Set canvas size to match video
                cameraCanvas.width = video.videoWidth;
                cameraCanvas.height = video.videoHeight;

                // Show camera container, hide video container
                const cameraContainer = document.getElementById('cameraContainer');
                cameraContainer.style.display = 'block';
                cameraContainer.classList.add('active');
                document.getElementById('videoContainer').classList.remove('active');

                showStatus('Camera Active - Point at people to see their balance!', 'ready');
                setTimeout(() => hideStatus(), 3000);

                // Start real-time detection
                isDetecting = true;
                detectLive(video);

            } catch (error) {
                console.error('Camera error:', error);
                
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    showStatus('Camera access denied. Please allow camera permissions and try again.', 'error');
                } else if (error.name === 'NotFoundError') {
                    showStatus('No camera found on this device.', 'error');
                } else if (error.name === 'NotReadableError') {
                    showStatus('Camera is being used by another application.', 'error');
                } else {
                    showStatus('Failed to access camera. Please try again.', 'error');
                }
            }
        }

        // Close modal
        function closeModal() {
            document.getElementById('permissionModal').classList.remove('active');
        }

        // Real-time detection loop
        async function detectLive(video) {
            if (!isDetecting) return;

            try {
                // Draw current frame
                cameraCtx.drawImage(video, 0, 0, cameraCanvas.width, cameraCanvas.height);

                // Detect faces
                let faces = [];
                if (model) {
                    try {
                        faces = await model.estimateFaces(cameraCanvas, false);
                    } catch (e) {
                        console.error('Face detection error:', e);
                        // Continue without faces
                    }
                }

                // Draw balance overlays for each face
                for (const face of faces) {
                    const balance = estimateWealth(face, cameraCtx, cameraCanvas);
                    
                    const x = (face.topLeft[0] + face.bottomRight[0]) / 2;
                    const y = Math.max(30, face.topLeft[1] - 30); // Ensure it's not off-screen

                    drawBalanceOverlay(x, y, balance, cameraCtx);
                }

                // If no faces detected and model loaded, show occasional random balance for fun
                if (faces.length === 0 && model && Math.random() > 0.98) {
                    const x = cameraCanvas.width * 0.5;
                    const y = cameraCanvas.height * 0.3;
                    const balance = generateRandomWealth();
                    drawBalanceOverlay(x, y, balance, cameraCtx);
                }

                // If no model loaded, show random balances at different positions occasionally
                if (!model && Math.random() > 0.95) {
                    const x = cameraCanvas.width * (0.3 + Math.random() * 0.4);
                    const y = cameraCanvas.height * (0.2 + Math.random() * 0.3);
                    const balance = generateRandomWealth();
                    drawBalanceOverlay(x, y, balance, cameraCtx);
                }

            } catch (error) {
                console.error('Detection loop error:', error);
            }

            // Continue detection
            if (isDetecting) {
                requestAnimationFrame(() => detectLive(video));
            }
        }

        // Draw balance overlay helper
        function drawBalanceOverlay(x, y, balance, context) {
            const balanceText = 'Balance: ' + formatWealth(balance);

            context.save();
            context.fillStyle = 'rgba(26, 32, 44, 0.95)';
            context.strokeStyle = '#48bb78';
            context.lineWidth = 2;
            
            context.font = 'bold 18px -apple-system, BlinkMacSystemFont, sans-serif';
            const textWidth = context.measureText(balanceText).width;
            const padding = 20;
            const boxWidth = textWidth + padding * 2;
            const boxHeight = 40;
            
            // Try roundRect, fallback to regular rect if not supported
            try {
                context.beginPath();
                if (typeof context.roundRect === 'function') {
                    context.roundRect(x - boxWidth/2, y - boxHeight/2, boxWidth, boxHeight, 20);
                } else {
                    // Fallback: draw rectangle with manual rounded corners
                    const radius = 20;
                    const rectX = x - boxWidth/2;
                    const rectY = y - boxHeight/2;
                    
                    context.moveTo(rectX + radius, rectY);
                    context.lineTo(rectX + boxWidth - radius, rectY);
                    context.quadraticCurveTo(rectX + boxWidth, rectY, rectX + boxWidth, rectY + radius);
                    context.lineTo(rectX + boxWidth, rectY + boxHeight - radius);
                    context.quadraticCurveTo(rectX + boxWidth, rectY + boxHeight, rectX + boxWidth - radius, rectY + boxHeight);
                    context.lineTo(rectX + radius, rectY + boxHeight);
                    context.quadraticCurveTo(rectX, rectY + boxHeight, rectX, rectY + boxHeight - radius);
                    context.lineTo(rectX, rectY + radius);
                    context.quadraticCurveTo(rectX, rectY, rectX + radius, rectY);
                    context.closePath();
                }
                context.fill();
                context.stroke();
            } catch (error) {
                console.error('Drawing error:', error);
                // Ultimate fallback: simple rectangle
                context.fillRect(x - boxWidth/2, y - boxHeight/2, boxWidth, boxHeight);
                context.strokeRect(x - boxWidth/2, y - boxHeight/2, boxWidth, boxHeight);
            }

            // Draw text
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(balanceText, x, y);
            
            context.restore();
        }

        // Stop camera
        function stopCamera() {
            isDetecting = false;
            
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }

            const cameraContainer = document.getElementById('cameraContainer');
            cameraContainer.classList.remove('active');
            cameraContainer.style.display = 'none';
            hideStatus();
        }

        // Switch between front and back camera
        async function switchCamera() {
            currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            
            try {
                await startCamera();
            } catch (error) {
                console.error('Camera switch failed:', error);
                // Try to switch back to previous mode
                currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
                showStatus('Camera switch failed. This device may only have one camera.', 'error');
                setTimeout(() => hideStatus(), 3000);
            }
        }

        // Capture photo from live camera
        function capturePhoto() {
            if (!cameraStream) return;

            // Create a temporary canvas with current frame
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = cameraCanvas.width;
            tempCanvas.height = cameraCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Copy current frame with overlays
            tempCtx.drawImage(cameraCanvas, 0, 0);

            // Convert to blob and download
            tempCanvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `balance-scan-${Date.now()}.jpg`;
                a.click();
                URL.revokeObjectURL(url);
                
                showStatus('Photo Captured!', 'ready');
                setTimeout(() => hideStatus(), 2000);
            }, 'image/jpeg', 0.9);
        }

        // Recording
        async function startRecording() {
            try {
                // Stop live camera if active
                if (cameraStream) {
                    stopCamera();
                }

                showStatus('Requesting camera access...', 'processing');

                const constraints = {
                    video: { 
                        facingMode: currentFacingMode,
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: true
                };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);

                // Check if MediaRecorder is supported
                if (!MediaRecorder.isTypeSupported('video/webm')) {
                    throw new Error('Video recording not supported in this browser');
                }

                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'video/webm'
                });
                
                recordedChunks = [];

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        recordedChunks.push(e.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    const file = new File([blob], 'recording.webm', { type: 'video/webm' });
                    videoFile = file;
                    processVideo(file);
                    stream.getTracks().forEach(track => track.stop());
                };

                mediaRecorder.onerror = (error) => {
                    console.error('Recording error:', error);
                    showStatus('Recording failed. Please try again.', 'error');
                    stream.getTracks().forEach(track => track.stop());
                };

                mediaRecorder.start();
                showStatus('üî¥ Recording... (max 30 seconds) Click to stop', 'processing');

                // Stop after 30 seconds or on click
                const stopRecording = () => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                        hideStatus();
                        document.getElementById('status').onclick = null;
                    }
                };

                setTimeout(stopRecording, 30000);
                document.getElementById('status').onclick = stopRecording;

            } catch (error) {
                console.error('Recording error:', error);
                
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    showStatus('Camera/microphone access denied. Please allow permissions and try again.', 'error');
                } else if (error.name === 'NotFoundError') {
                    showStatus('No camera or microphone found on this device.', 'error');
                } else {
                    showStatus('Failed to start recording: ' + error.message, 'error');
                }
            }
        }

        // UI helpers
        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status ' + type;
            status.style.display = 'block';
        }

        function hideStatus() {
            document.getElementById('status').style.display = 'none';
        }

        function showProgress(show) {
            document.getElementById('progressBar').classList.toggle('active', show);
        }

        function updateProgress(percent) {
            document.getElementById('progressFill').style.width = percent + '%';
        }

        // Initialize on load
        init();

        // Check if running on HTTPS or localhost (required for camera)
        window.addEventListener('load', () => {
            const isSecure = window.location.protocol === 'https:' || 
                           window.location.hostname === 'localhost' || 
                           window.location.hostname === '127.0.0.1';
            
            if (!isSecure) {
                showStatus('‚ö†Ô∏è HTTPS required for camera access. Please deploy to Vercel or use localhost.', 'error');
            }

            // Check if running as iOS standalone PWA
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            const isStandalone = window.navigator.standalone === true || 
                               window.matchMedia('(display-mode: standalone)').matches;
            
            if (isIOS && isStandalone) {
                showStatus('‚ö†Ô∏è Camera not available in installed iOS apps. Please use Safari browser instead.', 'error');
                // Disable camera buttons
                document.querySelectorAll('button').forEach(btn => {
                    if (btn.textContent.includes('Camera') || btn.textContent.includes('Record')) {
                        btn.disabled = true;
                        btn.style.opacity = '0.5';
                    }
                });
            }
        });
    </script>
</body>
</html>